#include <GL/glut.h>
#include <assert.h>
#include <stdio.h>
#include <math.h>
#include <stdarg.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>

#include "quadtree.h"
#include "font.h"

#define RADIUS (1<<20)

static struct quadtree *qt;

static float elevation, bearing;
static int wireframe = 0;
static int update_view = 1;

#define GLERROR()							\
do {									\
	GLenum err = glGetError();					\
	if (err != GL_NO_ERROR) {					\
		printf("GL error at %s:%d: %s\n",			\
		       __FILE__, __LINE__, gluErrorString(err));	\
	}								\
} while(0)

static unsigned pow2(unsigned x)
{
	return 1 << (32 - __builtin_clz(x-1));
}

static const char *id2str(const struct patch *p)
{
	int id = p->id;
	int level = p->level;
	static char buf[40];
	char *cp = buf;

	//cp += sprintf(cp, "%d:", level);
	*cp++ = '>';
	cp += sprintf(cp, "%d:", id >> (level * 2));

	for(int i = level-1; i >= 0; i--) {
		cp += sprintf(cp, "%d.", (id >> (i * 2)) & 3);
	}
	cp[-1] = '\0';

	return buf;
}

static void texprintf(const char *fmt, ...)
{
	unsigned len;
	char buf[1024];
	va_list ap;
	unsigned pix;

	va_start(ap, fmt);
	len = vsnprintf(buf, sizeof(buf), fmt, ap);
	va_end(ap);

	pix = pow2(len * 8);

	//printf("  %dx%d tex \"%s\"\n", pix, pix, buf);

	unsigned char tex[pix*pix];
	memset(tex, 0, pix*pix);

	for(int i = 0; i < len; i++) {
		const unsigned char *src = &font[buf[i] * 64];
		unsigned char *dst = &tex[((pix - 8) * pix + (pix - len*8)) / 2 + i * 8];

		for(int y = 0; y < 8; y++) {
			memcpy(dst, src, 8);
			dst += pix;
			src += 8;
		}
	}

	glTexImage2D(GL_TEXTURE_2D, 0, GL_INTENSITY, 
		     pix, pix, 0,
		     GL_LUMINANCE, GL_UNSIGNED_BYTE,
		     tex);
	GLERROR();
}

static int width, height;

static
void reshape (int w, int h)
{
	width = w;
	height = h;

	glEnable(GL_SCISSOR_TEST);
	glScissor(0,0,w,h);
	glViewport(0, 0, w, h);

	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	gluPerspective(50., 16./9., RADIUS/100, RADIUS*4);

	glMatrixMode(GL_MODELVIEW);
}

static void set_texture(const struct patch *p)
{
	GLuint texid = (p->id+1) + (1 << (p->level * 2 + 4));

	if (!glIsTexture(texid)) {
		const char *s = id2str(p);
		if (0)
			printf("generating tex %u for p=%p %d:%lu %s\n",
			       texid, p, p->level,p->id, s);

		glBindTexture(GL_TEXTURE_2D, texid);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);

		texprintf("%s", s);
	} else
		glBindTexture(GL_TEXTURE_2D, texid);
}

static float delta = 1;

static float dolly = -RADIUS * 2.5;
static void display()
{
	static float angle;

	glClearColor(.2,.2,.2,1);
	glDepthMask(GL_TRUE);
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();
	//gluLookAt(500,-3000,1100, 0,0,0, 0,0,1);
	glTranslatef(0, 0, dolly);
	glRotatef(elevation, 1, 0, 0);
	glRotatef(bearing, 0, 1, 0);
	//glRotatef(angle, 0, 1, 1);
	angle += delta;
	GLERROR();


	if (update_view) {
		GLfloat mv[16], proj[16];
		GLint viewport[4];

		glGetFloatv(GL_MODELVIEW_MATRIX, mv);
		GLERROR();
		glGetFloatv(GL_PROJECTION_MATRIX, proj);
		GLERROR();
		glGetIntegerv(GL_VIEWPORT, viewport);
		GLERROR();

		quadtree_update_view(qt, mv, proj, viewport);
	}


	glEnable(GL_TEXTURE_2D);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
	GLERROR();
	glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_BLEND);
	GLERROR();

	glColor3f(1,1,1);
	glEnable(GL_CULL_FACE);
	if (wireframe) {
		glPolygonMode(GL_FRONT, GL_LINE);
		glDisable(GL_LIGHTING);
	} else {
		glPolygonMode(GL_FRONT, GL_FILL);
		glEnable(GL_LIGHTING);
		glEnable(GL_COLOR_MATERIAL);
	}

	//glDisable(GL_TEXTURE_2D);
	glDisable(GL_BLEND);
	glEnable(GL_DEPTH_TEST);
	GLERROR();

	glMatrixMode(GL_TEXTURE);
	glLoadIdentity();
	glScalef(1./PATCH_SAMPLES, 1./PATCH_SAMPLES, 1);
	glMatrixMode(GL_MODELVIEW);

	quadtree_render(qt, set_texture);

#if 0
	glEnable(GL_POLYGON_OFFSET_LINE);
	glPolygonMode(GL_FRONT, GL_LINE);
	glDisable(GL_TEXTURE_2D);
	glDisable(GL_BLEND);
	glDisable(GL_LIGHTING);
	glBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
	glColor4f(.2,.2,.2,.2);
	glPolygonOffset(2,4);
	glDepthMask(GL_FALSE);
	GLERROR();

	quadtree_render(qt, NULL);
#endif

	glutSwapBuffers();

	//usleep(10000);
	//glutPostRedisplay();
}

static void keydown(unsigned char key, int x, int y)
{
	switch(key) {
	case 'o':
		update_view = !update_view;
		break;

	case 'd':
		wireframe = !wireframe;
		break;

	case 'x':
	case 27:
		exit(0);
	}

	glutPostRedisplay();
}

static void keyup(unsigned char key, int x, int y)
{
	switch(key) {
	case 'o':
		break;
	}
}

static int drag = 0, spin = 0;
static int lasty = 0;

static void motion(int x, int y)
{
	if (drag) {
		dolly += (y - lasty) * RADIUS/1024;
		if (dolly > -RADIUS * 1.01)
			dolly = -RADIUS * 1.01;

		//printf("dolly = %g\n", dolly);
		lasty = y;
	} else if (spin) {
		elevation = y * 360 / height;
		bearing = x * 360 / width;
	}

	glutPostRedisplay();
}

static void mouse(int buttons, int state, int x, int y)
{
	if (state != GLUT_DOWN) {
		spin = drag = 0;
		return;
	}

	if (buttons == GLUT_LEFT_BUTTON)
		spin = 1;
	else if (buttons == GLUT_MIDDLE_BUTTON) {
		lasty = y;
		drag = 1;
	}

	glutPostRedisplay();
}

static const GLubyte gradient[] = {
	0x06, 0x1d, 0x98,
	0x07, 0x1e, 0x99,
	0x08, 0x1e, 0x99,
	0x08, 0x1f, 0x99,
	0x09, 0x1f, 0x9a,
	0x09, 0x20, 0x9a,
	0x0a, 0x20, 0x9b,
	0x0b, 0x21, 0x9b,
	0x0a, 0x21, 0x9b,
	0x0b, 0x21, 0x9b,
	0x0c, 0x22, 0x9c,
	0x0c, 0x23, 0x9d,
	0x0c, 0x23, 0x9d,
	0x0d, 0x24, 0x9d,
	0x0e, 0x24, 0x9e,
	0x0e, 0x25, 0x9e,
	0x0f, 0x25, 0x9f,
	0x0f, 0x25, 0x9f,
	0x0f, 0x26, 0x9f,
	0x10, 0x26, 0x9f,
	0x11, 0x26, 0xa0,
	0x11, 0x28, 0xa0,
	0x12, 0x27, 0xa1,
	0x12, 0x28, 0xa2,
	0x13, 0x29, 0xa2,
	0x14, 0x29, 0xa3,
	0x14, 0x2a, 0xa3,
	0x14, 0x2a, 0xa3,
	0x14, 0x2b, 0xa3,
	0x15, 0x2b, 0xa4,
	0x16, 0x2b, 0xa5,
	0x17, 0x2c, 0xa5,
	0x17, 0x2d, 0xa5,
	0x17, 0x2d, 0xa6,
	0x18, 0x2d, 0xa6,
	0x19, 0x2e, 0xa7,
	0x19, 0x2f, 0xa6,
	0x1a, 0x2f, 0xa7,
	0x1a, 0x2f, 0xa7,
	0x1b, 0x30, 0xa8,
	0x1b, 0x31, 0xa9,
	0x1c, 0x31, 0xa9,
	0x1c, 0x31, 0xa9,
	0x1c, 0x32, 0xa9,
	0x1d, 0x32, 0xaa,
	0x1e, 0x33, 0xab,
	0x1e, 0x33, 0xab,
	0x1e, 0x34, 0xab,
	0x20, 0x35, 0xac,
	0x20, 0x35, 0xac,
	0x20, 0x36, 0xad,
	0x21, 0x36, 0xad,
	0x21, 0x36, 0xae,
	0x22, 0x36, 0xad,
	0x23, 0x37, 0xae,
	0x23, 0x38, 0xae,
	0x24, 0x38, 0xaf,
	0x24, 0x38, 0xb0,
	0x24, 0x39, 0xb0,
	0x25, 0x3a, 0xb0,
	0x25, 0x3a, 0xb0,
	0x26, 0x3a, 0xb1,
	0x26, 0x3a, 0xb2,
	0x27, 0x3c, 0xb2,
	0x28, 0x3c, 0xb2,
	0x28, 0x3d, 0xb3,
	0x29, 0x3d, 0xb3,
	0x29, 0x3d, 0xb4,
	0x29, 0x3e, 0xb4,
	0x2a, 0x3f, 0xb5,
	0x2b, 0x3f, 0xb5,
	0x2b, 0x3f, 0xb6,
	0x2c, 0x40, 0xb6,
	0x2c, 0x41, 0xb6,
	0x2c, 0x41, 0xb7,
	0x2d, 0x41, 0xb7,
	0x2e, 0x41, 0xb8,
	0x2e, 0x43, 0xb8,
	0x2f, 0x43, 0xb8,
	0x2f, 0x43, 0xb8,
	0x2f, 0x44, 0xb9,
	0x31, 0x44, 0xb9,
	0x30, 0x45, 0xb9,
	0x31, 0x45, 0xba,
	0x32, 0x46, 0xba,
	0x32, 0x46, 0xbb,
	0x33, 0x47, 0xbc,
	0x33, 0x47, 0xbc,
	0x34, 0x47, 0xbc,
	0x35, 0x48, 0xbc,
	0x35, 0x48, 0xbd,
	0x35, 0x49, 0xbe,
	0x35, 0x49, 0xbe,
	0x37, 0x4a, 0xbe,
	0x37, 0x4b, 0xbf,
	0x38, 0x4b, 0xbf,
	0x37, 0x4b, 0xbf,
	0x38, 0x4c, 0xc0,
	0x39, 0x4c, 0xc0,
	0x39, 0x4d, 0xc0,
	0x3a, 0x4e, 0xc1,
	0x3a, 0x4e, 0xc2,
	0x3b, 0x4e, 0xc2,
	0x3b, 0x4f, 0xc2,
	0x3c, 0x4f, 0xc3,
	0x3c, 0x50, 0xc3,
	0x3d, 0x50, 0xc4,
	0x3d, 0x51, 0xc4,
	0x3e, 0x51, 0xc4,
	0x3f, 0x51, 0xc5,
	0x3f, 0x52, 0xc5,
	0x3f, 0x53, 0xc6,
	0x40, 0x53, 0xc6,
	0x40, 0x53, 0xc7,
	0x41, 0x54, 0xc7,
	0x42, 0x55, 0xc7,
	0x42, 0x54, 0xc8,
	0x43, 0x55, 0xc8,
	0x43, 0x55, 0xc8,
	0x43, 0x56, 0xc9,
	0x44, 0x57, 0xc9,
	0x44, 0x58, 0xca,
	0x45, 0x58, 0xca,
	0x46, 0x58, 0xcb,
	0x48, 0x5a, 0xcd,
	0x4d, 0x5f, 0xd0,
	0x53, 0x65, 0xd5,
	0x58, 0x69, 0xd9,
	0x5d, 0x6e, 0xdd,
	0x62, 0x73, 0xe1,
	0x67, 0x78, 0xe5,
	0x6d, 0x7d, 0xea,
	0x71, 0x81, 0xee,
	0x77, 0x86, 0xf2,
	0x7c, 0x8b, 0xf6,
	0x81, 0x90, 0xfa,
	0x87, 0x95, 0xff,
	0x8b, 0x99, 0xfa,
	0x8e, 0x9c, 0xf4,
	0x92, 0x9f, 0xee,
	0x97, 0xa3, 0xe7,
	0x9b, 0xa6, 0xe2,
	0x9e, 0xa9, 0xdc,
	0xa2, 0xad, 0xd6,
	0xa7, 0xb0, 0xd0,
	0xaa, 0xb4, 0xca,
	0xaf, 0xb7, 0xc4,
	0xb3, 0xba, 0xbe,
	0xb6, 0xbe, 0xb8,
	0xbb, 0xc1, 0xb3,
	0xbe, 0xc5, 0xad,
	0xc2, 0xc9, 0xa7,
	0xd6, 0xda, 0x89,
	0xee, 0xed, 0x66,
	0xf6, 0xf6, 0x4a,
	0xcf, 0xe0, 0x42,
	0xa8, 0xca, 0x3a,
	0x89, 0xb9, 0x34,
	0x85, 0xb6, 0x34,
	0x81, 0xb4, 0x33,
	0x7e, 0xb1, 0x32,
	0x7a, 0xaf, 0x31,
	0x75, 0xad, 0x31,
	0x71, 0xab, 0x2f,
	0x6d, 0xa8, 0x2f,
	0x69, 0xa6, 0x2d,
	0x66, 0xa4, 0x2d,
	0x62, 0xa1, 0x2d,
	0x5d, 0x9f, 0x2b,
	0x59, 0x9d, 0x2b,
	0x55, 0x9a, 0x29,
	0x51, 0x98, 0x28,
	0x4d, 0x96, 0x28,
	0x49, 0x94, 0x27,
	0x46, 0x91, 0x26,
	0x41, 0x90, 0x26,
	0x3e, 0x8c, 0x24,
	0x39, 0x8a, 0x24,
	0x35, 0x88, 0x23,
	0x32, 0x86, 0x23,
	0x2d, 0x84, 0x21,
	0x2a, 0x81, 0x21,
	0x25, 0x7f, 0x20,
	0x22, 0x7d, 0x1f,
	0x1e, 0x7b, 0x1f,
	0x19, 0x78, 0x1e,
	0x16, 0x76, 0x1d,
	0x19, 0x77, 0x20,
	0x1e, 0x78, 0x25,
	0x23, 0x78, 0x29,
	0x27, 0x7a, 0x2d,
	0x2b, 0x7a, 0x31,
	0x2f, 0x7b, 0x36,
	0x34, 0x7c, 0x3a,
	0x38, 0x7d, 0x3e,
	0x3d, 0x7e, 0x42,
	0x41, 0x7f, 0x46,
	0x45, 0x80, 0x4a,
	0x4a, 0x81, 0x4e,
	0x4f, 0x82, 0x52,
	0x53, 0x83, 0x57,
	0x58, 0x84, 0x5c,
	0x5d, 0x84, 0x60,
	0x63, 0x86, 0x66,
	0x68, 0x86, 0x6a,
	0x6d, 0x88, 0x6f,
	0x72, 0x89, 0x73,
	0x78, 0x8a, 0x79,
	0x7c, 0x8b, 0x7e,
	0x82, 0x8d, 0x83,
	0x87, 0x8d, 0x88,
	0x8c, 0x8f, 0x8d,
	0x90, 0x90, 0x90,
	0x93, 0x93, 0x93,
	0x95, 0x96, 0x95,
	0x98, 0x98, 0x98,
	0x9b, 0x9b, 0x9b,
	0x9d, 0x9d, 0x9d,
	0x9f, 0x9f, 0xa0,
	0xa2, 0xa2, 0xa2,
	0xa5, 0xa4, 0xa5,
	0xa7, 0xa7, 0xa7,
	0xaa, 0xaa, 0xaa,
	0xac, 0xac, 0xac,
	0xaf, 0xaf, 0xaf,
	0xb1, 0xb1, 0xb1,
	0xb4, 0xb4, 0xb4,
	0xb6, 0xb6, 0xb7,
	0xb9, 0xb9, 0xb9,
	0xbb, 0xbb, 0xbc,
	0xbe, 0xbe, 0xbe,
	0xc0, 0xc1, 0xc0,
	0xc3, 0xc2, 0xc3,
	0xc5, 0xc5, 0xc6,
	0xc8, 0xc8, 0xc7,
	0xca, 0xcb, 0xcb,
	0xcd, 0xcd, 0xcd,
	0xd0, 0xd0, 0xd0,
	0xd3, 0xd2, 0xd3,
	0xd5, 0xd5, 0xd5,
	0xd8, 0xd7, 0xd8,
	0xda, 0xda, 0xda,
	0xdc, 0xdd, 0xdc,
	0xdf, 0xdf, 0xdf,
	0xe1, 0xe2, 0xe2,
	0xe4, 0xe4, 0xe4,
	0xe6, 0xe6, 0xe6,
	0xe9, 0xe9, 0xe9,
	0xec, 0xeb, 0xeb,
	0xed, 0xed, 0xed,
	0xef, 0xef, 0xef,
	0xf2, 0xf1, 0xf1,
	0xf3, 0xf2, 0xf2,
	0xf4, 0xf4, 0xf4,
	0xf5, 0xf4, 0xf4,
	0xf4, 0xf5, 0xf4,
};

static elevation_t generate(long x, long y, long z, GLubyte col[4])
{
	float height;
	elevation_t e;

	//printf("x=%ld y=%ld z=%ld\n", x, y, z);

	height = (cos((float) x * M_PI * 2 / RADIUS) + 
		  sin((float) y * M_PI * 2 / (RADIUS*2)) +
		  sin((float) z * M_PI * 2 / (RADIUS*.8))*1.2);

	e = height * (RADIUS * .02);

	col[3] = 0xff;

	int idx = (height / 3) * 255 + 150;
	if (idx < 0)
		idx = 0;
	if (idx > 255)
		idx = 255;

	col[0] = gradient[idx * 3 + 0];
	col[1] = gradient[idx * 3 + 1];
	col[2] = gradient[idx * 3 + 2];

	return e;
}

int main(int argc, char **argv)
{
	glutInit(&argc, argv);
        glutInitDisplayMode(GLUT_RGB | GLUT_DOUBLE | GLUT_DEPTH);
        glutInitWindowSize(480*2, 272*2);
	glutCreateWindow( __FILE__ );

	qt = quadtree_create(200, RADIUS, generate);
	
	//glutSpecialFunc(special_down);
	glutKeyboardFunc(keydown);
	glutKeyboardUpFunc(keyup);
	glutReshapeFunc(reshape);
	glutDisplayFunc(display);
	//glutPassiveMotionFunc(motion);
	glutMotionFunc(motion);
	glutMouseFunc(mouse);

	{
		GLfloat diffcol0[] = { .4, .4, 1, 1 };
		GLfloat lightdir0[] = { 0, 0, 1, 0 };
		GLfloat diffcol1[] = { .6, .2, .1, 1 };
		GLfloat lightdir1[] = { .707, .707, 0, 0 };

		glEnable(GL_LIGHTING);

		glEnable(GL_LIGHT0);
		glLightfv(GL_LIGHT0, GL_DIFFUSE, diffcol0);
		glLightfv(GL_LIGHT0, GL_POSITION, lightdir0);

		glEnable(GL_LIGHT1);
		glLightfv(GL_LIGHT1, GL_DIFFUSE, diffcol1);
		glLightfv(GL_LIGHT1, GL_POSITION, lightdir1);
	}

	glutMainLoop();
}
